global n  #dimensions
global pos  #position of bot 
global pos2 #position of princess
global op # possible moves
global res #selected move in order

n=int(input())
op=list()
res=list()

for x in range(n):
    inv=input()
    if "m" in inv:
        pos=(x, inv.index("m"))
    if "p" in inv:
        pos2=(x, inv.index("p"))
        
def dist(i1,i2): #Euler's Distance
    temp=((i1[0]-i2[0])**2+(i1[1]-i2[1])**2)
    return(round(temp**(0.5),4))
    
def moveup(ln):
    global pos
    if pos[0]==0:
        return 0
    else:
        pos=(pos[0]-1,pos[1])
        return 1
        
 def movedown(ln):
    global pos
    global n
    if pos[0]==n-1:
        return 0
    else:
        #ln[pos[0]][pos[1]] = "-"
        pos=(pos[0]+1,pos[1])
        #ln[pos[0]][pos[1]]="m"
        return 1

def moveleft(ln):
    global pos
    global n
    if pos[1]==0:
        return 0
    else:
        pos=(pos[0],pos[1]-1)
        return 1

def moveright(ln):
    global pos
    global n
    if pos[1]==n-1:
        return 0
    else:
        pos=(pos[0],pos[1]+1)
        return 1

def options(ln): # Available moves for the bot at a specific position 
    global op
    if moveup(ln)==1:
        op.append(1)
        movedown(ln)
    else:
        op.append(0)
    if movedown(ln)==1:
        op.append(1)
        moveup(ln)
    else:
        op.append(0)
    if moveleft(ln)==1:
        op.append(1)
        moveright(ln)
    else:
        op.append(0)
    if moveright(ln)==1:
        op.append(1)
        moveleft(ln)
    else:
        op.append(0)


# 0-Up
# 1-Down
# 2-Left
# 3-Right

def searchp(ln):        # A* algorithm. f(x)=h(x)+g(x), h(x) is the heuristic value and g(x) is the actual distance to the target
    global n            # Our aim is to minimise f(x) and employ recursion the find the number of steps
    global pos
    global pos2
    global op
    global res

    op=[]

    options(ln)
    m=list()
    if op[0]==1:
        temp=dist(pos,pos2)
        moveup(ln)
        temp+=dist(pos,pos2)
        movedown(ln)
        m.append((temp,0))
    if op[1]==1:
        temp=dist(pos,pos2)
        movedown(ln)
        temp+=dist(pos,pos2)
        moveup(ln)
        m.append((temp,1))
    if op[2]==1:
        temp=dist(pos,pos2)
        moveleft(ln)
        temp+=dist(pos,pos2)
        moveright(ln)
        m.append((temp,2))
    if op[3]==1:
        temp=dist(pos,pos2)
        moveright(ln)
        temp+=dist(pos,pos2)
        moveleft(ln)
        m.append((temp,3))

    m=min(m)                # f(x) is minimised
    
    res.append(m[1])
    if m[1]==0:
        moveup(ln)
    elif m[1]==1:
        movedown(ln)
    elif m[1]==2:
        moveleft(ln)
    elif m[1]==3:
        moveright(ln)
                            #move made using m

    if pos==pos2:
        return 0            # exit
    else:
        return(searchp(ln))   #recursion

